Python renderer for SpatOSC
===========================

Pyospat is a Python audio renderer for SpatOSC.

See http://code.sat.qc.ca/trac/spatosc for more information.


Developers
==========

  $ python setup.py build
  $ sudo python setup.py develop

  $ cp dot_pyorc.xml ~/.pyorc
  $ python
  >>> from pyospat import server 
  >>> s = server.ServerWrapper()
  >>> s.run()


Versioning
==========

This project uses the common "Linux kernel" versioning system, where even-numbered minor versions are stable and odd-numbered minor versions are development snapshots.

The micro version indicates the origin of the release: even micro numbers are only used for released archives; odd micro numbers are only used on the Git repository.

A stable series means that the command-line options and the interactive keyboard controls should not change much for all tags whose version number start with the same major-minor numbers. Some new features might be developped in that branch, but each release should be backward-compatible with their ancestor. Releases from a stable series should be use for production. 

In contrast, unstable branches consist of tags which are developer snapshots. They are not expected to be compatible with any other version. Some features might change between different stable branches.


Naming
======

 * pyospat
 * pyspat
 * python spatosc renderer
 * pyo spatosc audio renderer


How it works
============

Pyospat is an application that listens to OSC messages from SpatOSC. It dynamically creates Pyo objects and connects them together to make you hear stuff. It can be configured with an XML file in which you define how are configured your audio speakers, as well as how many audio inputs your system has and which driver to use, etc. It can play sound files as well as plugin generators and live input channels.

Use string properties when it's specific for a single renderer. 

Every sound sources should have a media URI.

Things that should be configurable in the XML file:
 * loudspeakers configuration

How to compute audio
====================
It's done in a two-step process:

1) distance from listener: (meter)
 * low-pass filter
 * variable delay
 * attenuation gain (configurable)

2) azimuth/elevation: (angle)
 * two panners

